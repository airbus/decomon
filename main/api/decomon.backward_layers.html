

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>decomon.backward_layers package &mdash; DecoMon main documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/versions.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="decomon.corners package" href="decomon.corners.html" />
    <link rel="prev" title="decomon.applications.cv package" href="decomon.applications.cv.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> DecoMon
          

          
          </a>

          
            
            
              <div class="version">
                main
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="decomon.html">decomon package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="decomon.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="decomon.applications.html">decomon.applications package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">decomon.backward_layers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.corners.html">decomon.corners package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.layers.html">decomon.layers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.loading.html">decomon.loading package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.metrics.html">decomon.metrics package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.models.html">decomon.models package</a></li>
<li class="toctree-l4"><a class="reference internal" href="decomon.types.html">decomon.types package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="decomon.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="decomon.html#module-decomon.utils">decomon.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="decomon.html#module-decomon.wrapper">decomon.wrapper module</a></li>
<li class="toctree-l3"><a class="reference internal" href="decomon.html#module-decomon.wrapper_with_tuning">decomon.wrapper_with_tuning module</a></li>
<li class="toctree-l3"><a class="reference internal" href="decomon.html#module-decomon">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/airbus/decomon">Github</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DecoMon</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">API Reference</a> &raquo;</li>
        
          <li><a href="decomon.html">decomon package</a> &raquo;</li>
        
      <li>decomon.backward_layers package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="decomon-backward-layers-package">
<h1>decomon.backward_layers package<a class="headerlink" href="#decomon-backward-layers-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-decomon.backward_layers.activations">
<span id="decomon-backward-layers-activations-module"></span><h2>decomon.backward_layers.activations module<a class="headerlink" href="#module-decomon.backward_layers.activations" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_elu">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_elu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_elu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_elu" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of Exponential Linear Unit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_exponential">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_exponential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_exponential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPAof exponential</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_hard_sigmoid">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_hard_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_hard_sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_hard_sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of hard sigmoid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_linear">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPA of linear</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_relu">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_relu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_relu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of relu</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>alpha</strong> – </p></li>
<li><p><strong>max_value</strong> – </p></li>
<li><p><strong>threshold</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_selu">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_selu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_selu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_selu" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPA of Scaled Exponential Linear Unit (SELU)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_sigmoid">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of sigmoid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_softmax">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_softmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_softmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPA of softmax</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
<li><p><strong>axis</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_softplus">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_softplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_softplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_softplus" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPA of softplus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_softsign">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_softsign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_softsign"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_softsign" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward LiRPA of softsign</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – backward slope</p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_softsign_">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_softsign_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_softsign_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_softsign_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.backward_tanh">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">backward_tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_decomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#backward_tanh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.backward_tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of tanh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – </p></li>
<li><p><strong>dc_decomp</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.deserialize">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">deserialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#deserialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the activation from name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> – name of the method.</p>
</dd>
</dl>
<p>among the implemented Keras activation function.</p>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.activations.get">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.activations.</span></span><span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/activations.html#get"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.activations.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <cite>identifier</cite> activation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>identifier</strong> – None or str, name of the function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The activation function, <cite>linear</cite> if <cite>identifier</cite> is None.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-decomon.backward_layers.backward_layers">
<span id="decomon-backward-layers-backward-layers-module"></span><h2>decomon.backward_layers.backward_layers module<a class="headerlink" href="#module-decomon.backward_layers.backward_layers" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardActivation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.build" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_shape</strong> – list of input shape</p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.freeze_alpha">
<span class="sig-name descname"><span class="pre">freeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.freeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.freeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.freeze_grid">
<span class="sig-name descname"><span class="pre">freeze_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.freeze_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.freeze_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.unfreeze_alpha">
<span class="sig-name descname"><span class="pre">unfreeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.unfreeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.unfreeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardActivation.unfreeze_grid">
<span class="sig-name descname"><span class="pre">unfreeze_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardActivation.unfreeze_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardActivation.unfreeze_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardBatchNormalization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardBatchNormalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardBatchNormalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardBatchNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Batch Normalization</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardBatchNormalization.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardBatchNormalization.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardBatchNormalization.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardConv2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Conv2D</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.build" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_shape</strong> – list of input shape</p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.freeze_alpha">
<span class="sig-name descname"><span class="pre">freeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.freeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.freeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.freeze_weights">
<span class="sig-name descname"><span class="pre">freeze_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.freeze_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.freeze_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.get_bounds_linear">
<span class="sig-name descname"><span class="pre">get_bounds_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.get_bounds_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.get_bounds_linear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.reset_finetuning">
<span class="sig-name descname"><span class="pre">reset_finetuning</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.reset_finetuning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.reset_finetuning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.unfreeze_alpha">
<span class="sig-name descname"><span class="pre">unfreeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.unfreeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.unfreeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardConv2D.unfreeze_weights">
<span class="sig-name descname"><span class="pre">unfreeze_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardConv2D.unfreeze_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardConv2D.unfreeze_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardDense</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Dense</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.build" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_shape</strong> – list of input shape</p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.freeze_alpha">
<span class="sig-name descname"><span class="pre">freeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.freeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.freeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.freeze_weights">
<span class="sig-name descname"><span class="pre">freeze_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.freeze_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.freeze_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.reset_finetuning">
<span class="sig-name descname"><span class="pre">reset_finetuning</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.reset_finetuning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.reset_finetuning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.unfreeze_alpha">
<span class="sig-name descname"><span class="pre">unfreeze_alpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.unfreeze_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.unfreeze_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDense.unfreeze_weights">
<span class="sig-name descname"><span class="pre">unfreeze_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDense.unfreeze_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDense.unfreeze_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDropout">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardDropout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDropout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Dropout</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardDropout.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardDropout.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardDropout.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardFlatten">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardFlatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardFlatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardFlatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Flatten</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardFlatten.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardFlatten.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardFlatten.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardInputLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardInputLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardInputLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardInputLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardInputLayer.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardInputLayer.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardInputLayer.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardInputLayer.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardInputLayer.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardInputLayer.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardInputLayer.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardInputLayer.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardInputLayer.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardPermute">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardPermute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardPermute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardPermute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward LiRPA of Permute</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardPermute.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardPermute.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardPermute.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardReshape">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">BackwardReshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardReshape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardReshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
<p>Backward  LiRPA of Reshape</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardReshape.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardReshape.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardReshape.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardReshape.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardReshape.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardReshape.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.BackwardReshape.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#BackwardReshape.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.BackwardReshape.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.get_backward">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">get_backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finetune</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#get_backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.get_backward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_layers.join">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_layers.</span></span><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_layers.html#join"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_layers.join" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-decomon.backward_layers.backward_maxpooling">
<span id="decomon-backward-layers-backward-maxpooling-module"></span><h2>decomon.backward_layers.backward_maxpooling module<a class="headerlink" href="#module-decomon.backward_layers.backward_maxpooling" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_maxpooling.BackwardMaxPooling2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_maxpooling.</span></span><span class="sig-name descname"><span class="pre">BackwardMaxPooling2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_maxpooling.html#BackwardMaxPooling2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_maxpooling.BackwardMaxPooling2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></p>
<p>Backward  LiRPA of MaxPooling2D</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_maxpooling.BackwardMaxPooling2D.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_maxpooling.html#BackwardMaxPooling2D.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_maxpooling.BackwardMaxPooling2D.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decomon.backward_layers.backward_merge">
<span id="decomon-backward-layers-backward-merge-module"></span><h2>decomon.backward_layers.backward_merge module<a class="headerlink" href="#module-decomon.backward_layers.backward_merge" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardAdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAdd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Add</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAdd.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAdd.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAdd.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAdd.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAdd.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAdd.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAdd.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAdd.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAdd.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAverage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Average</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAverage.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAverage.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAverage.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAverage.call_no_previous">
<span class="sig-name descname"><span class="pre">call_no_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAverage.call_no_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAverage.call_no_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardAverage.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardAverage.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardAverage.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardConcatenate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardConcatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardConcatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardConcatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Concatenate</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardConcatenate.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardConcatenate.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardConcatenate.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardDot">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardDot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardDot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Dot</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardDot.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardDot.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardDot.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMaximum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardMaximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMaximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMaximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Maximum</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMaximum.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMaximum.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMaximum.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMerge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardMerge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMerge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.core.BackwardLayer" title="decomon.backward_layers.core.BackwardLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardLayer</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMinimum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardMinimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMinimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMinimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Minimum</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMinimum.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMinimum.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMinimum.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMultiply">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardMultiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMultiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMultiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Multiply</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardMultiply.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardMultiply.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardMultiply.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardSubtract">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.backward_merge.</span></span><span class="sig-name descname"><span class="pre">BackwardSubtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardSubtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardSubtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#decomon.backward_layers.backward_merge.BackwardMerge" title="decomon.backward_layers.backward_merge.BackwardMerge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardMerge</span></code></a></p>
<p>Backward  LiRPA of Subtract</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.backward_merge.BackwardSubtract.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/backward_merge.html#BackwardSubtract.call"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.backward_merge.BackwardSubtract.call" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the layer’s logic lives.</p>
<p>The <cite>call()</cite> method may not create state (except in its first
invocation, wrapping the creation of variables or other resources in
<cite>tf.init_scope()</cite>).  It is recommended to create state, including
<cite>tf.Variable</cite> instances and nested <cite>Layer</cite> instances,</p>
<blockquote>
<div><p>in <cite>__init__()</cite>, or in the <cite>build()</cite> method that is</p>
</div></blockquote>
<p>called automatically before <cite>call()</cite> executes for the first time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – <p>Input tensor, or dict/list/tuple of input tensors.
The first positional <cite>inputs</cite> argument is subject to special rules:
- <cite>inputs</cite> must be explicitly passed. A layer cannot have zero</p>
<blockquote>
<div><p>arguments, and <cite>inputs</cite> cannot be provided via the default value
of a keyword argument.</p>
</div></blockquote>
<ul>
<li><p>NumPy array or Python scalar values in <cite>inputs</cite> get cast as
tensors.</p></li>
<li><p>Keras mask metadata is only collected from <cite>inputs</cite>.</p></li>
<li><p>Layers are built (<cite>build(input_shape)</cite> method)
using shape info from <cite>inputs</cite> only.</p></li>
<li><p><cite>input_spec</cite> compatibility is only checked against <cite>inputs</cite>.</p></li>
<li><p>Mixed precision input casting is only applied to <cite>inputs</cite>.
If a layer has tensor arguments in <cite>*args</cite> or <cite>**kwargs</cite>, their
casting behavior in mixed precision should be handled manually.</p></li>
<li><p>The SavedModel input specification is generated using <cite>inputs</cite>
only.</p></li>
<li><p>Integration with various ecosystem packages like TFMOT, TFLite,
TF.js, etc is only supported for <cite>inputs</cite> and not for tensors in
positional and keyword arguments.</p></li>
</ul>
</p></li>
<li><p><strong>*args</strong> – Additional positional arguments. May contain tensors, although
this is not recommended, for the reasons above.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional keyword arguments. May contain tensors, although
this is not recommended, for the reasons above.
The following optional keyword arguments are reserved:
- <cite>training</cite>: Boolean scalar tensor of Python boolean indicating</p>
<blockquote>
<div><p>whether the <cite>call</cite> is meant for training or inference.</p>
</div></blockquote>
<ul>
<li><p><cite>mask</cite>: Boolean input mask. If the layer’s <cite>call()</cite> method takes a
<cite>mask</cite> argument, its default value will be set to the mask
generated for <cite>inputs</cite> by the previous layer (if <cite>input</cite> did come
from a layer that generated a corresponding mask, i.e. if it came
from a Keras layer with masking support).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor or list/tuple of tensors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-decomon.backward_layers.backward_reshape">
<span id="decomon-backward-layers-backward-reshape-module"></span><h2>decomon.backward_layers.backward_reshape module<a class="headerlink" href="#module-decomon.backward_layers.backward_reshape" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-decomon.backward_layers.core">
<span id="decomon-backward-layers-core-module"></span><h2>decomon.backward_layers.core module<a class="headerlink" href="#module-decomon.backward_layers.core" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.core.BackwardLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.core.</span></span><span class="sig-name descname"><span class="pre">BackwardLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/core.html#BackwardLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.core.BackwardLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.core.BackwardLayer.set_previous">
<span class="sig-name descname"><span class="pre">set_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">previous</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/core.html#BackwardLayer.set_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.core.BackwardLayer.set_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-decomon.backward_layers.deel_lip">
<span id="decomon-backward-layers-deel-lip-module"></span><h2>decomon.backward_layers.deel_lip module<a class="headerlink" href="#module-decomon.backward_layers.deel_lip" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.deel_lip.BackwardDense">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.deel_lip.</span></span><span class="sig-name descname"><span class="pre">BackwardDense</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/deel_lip.html#BackwardDense"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.deel_lip.BackwardDense" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></p>
<p>Backward  LiRPA of Dense</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decomon.backward_layers.deel_lip.BackwardGroupSort2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.deel_lip.</span></span><span class="sig-name descname"><span class="pre">BackwardGroupSort2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/deel_lip.html#BackwardGroupSort2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.deel_lip.BackwardGroupSort2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></p>
<p>Backward LiRPA of GroupSort2</p>
<dl class="py method">
<dt class="sig sig-object py" id="decomon.backward_layers.deel_lip.BackwardGroupSort2.call_previous">
<span class="sig-name descname"><span class="pre">call_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/deel_lip.html#BackwardGroupSort2.call_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.deel_lip.BackwardGroupSort2.call_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-decomon.backward_layers.utils">
<span id="decomon-backward-layers-utils-module"></span><h2>decomon.backward_layers.utils module<a class="headerlink" href="#module-decomon.backward_layers.utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_add">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of inputs_0+inputs_1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs_0</strong> – </p></li>
<li><p><strong>inputs_1</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_linear_prod">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_linear_prod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">back_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_linear_prod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_linear_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of a subroutine prod</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds_x</strong> – </p></li>
<li><p><strong>back_bounds</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_max_">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_max_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_max_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of max</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – list of tensors</p></li>
<li><p><strong>dc_decomp</strong> – boolean that indicates</p></li>
<li><p><strong>grad_bounds</strong> – boolean that indicates whether</p></li>
<li><p><strong>convex_domain</strong> – the type of convex domain</p></li>
<li><p><strong>axis</strong> – axis to perform the maximum</p></li>
</ul>
</dd>
</dl>
<p>whether we return a difference of convex decomposition of our layer
we propagate upper and lower bounds on the values of the gradient</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>max operation  along an axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_maximum">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of maximum(inputs_0, inputs_1)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs_0</strong> – </p></li>
<li><p><strong>inputs_1</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_minimum">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_minimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of minimum(inputs_0, inputs_1)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs_0</strong> – </p></li>
<li><p><strong>inputs_1</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_minus">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_minus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of -x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_multiply">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of element-wise multiply inputs_0*inputs_1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs_0</strong> – </p></li>
<li><p><strong>inputs_1</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_relu_">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_relu_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_relu_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_relu_" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of relu</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
<li><p><strong>fast</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_scale">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_scale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of scale_factor*x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale_factor</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_softplus_">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_softplus_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_softplus_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_softplus_" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of relu</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
<li><p><strong>fast</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_sort">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'volume-slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of sort</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>axis</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>slope</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.backward_substract">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">backward_substract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_u_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_u_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_out_l_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_out_l_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#backward_substract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.backward_substract" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward  LiRPA of inputs_0 - inputs_1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs_0</strong> – </p></li>
<li><p><strong>inputs_1</strong> – </p></li>
<li><p><strong>w_out_u</strong> – </p></li>
<li><p><strong>b_out_u</strong> – </p></li>
<li><p><strong>w_out_l</strong> – </p></li>
<li><p><strong>b_out_l</strong> – </p></li>
<li><p><strong>convex_domain</strong> – </p></li>
<li><p><strong>mode</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.get_FORWARD">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">get_FORWARD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#get_FORWARD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.get_FORWARD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.get_IBP">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">get_IBP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hybrid'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#get_IBP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.get_IBP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.get_identity_lirpa">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">get_identity_lirpa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#get_identity_lirpa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.get_identity_lirpa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.get_input_dim">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decomon.backward_layers.utils.merge_with_previous">
<span class="sig-prename descclassname"><span class="pre">decomon.backward_layers.utils.</span></span><span class="sig-name descname"><span class="pre">merge_with_previous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/decomon/backward_layers/utils.html#merge_with_previous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#decomon.backward_layers.utils.merge_with_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-decomon.backward_layers">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-decomon.backward_layers" title="Permalink to this heading">¶</a></h2>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="decomon.corners.html" class="btn btn-neutral float-right" title="decomon.corners package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="decomon.applications.cv.html" class="btn btn-neutral float-left" title="decomon.applications.cv package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Airbus.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Versions</span>
      v: main
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl id="docs-versions">
      </dl>
    </div>
  </div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>